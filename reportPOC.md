{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9df247b1-b71d-41cc-a3ef-1d17752da253",
   "metadata": {},
   "source": [
    "# Rapport — Planification de trajectoire d’un robot mobile par SLPSO (Self-Adaptive Learning Particle Swarm Optimization)\n",
    "\n",
    "## Résumé\n",
    "Ce rapport présente une preuve de concept (PoC) de planification de trajectoire pour robot mobile en environnement 2D avec obstacles statiques. Le problème est formulé comme une optimisation multi-objectif minimisant simultanément : (i) la longueur du chemin, (ii) le risque de collision, et (iii) la douceur (smoothness) de la trajectoire. La méthode étudiée est SLPSO, une variante de PSO intégrant quatre opérateurs d’apprentissage et un mécanisme auto-adaptatif des probabilités de sélection.\n",
    "\n",
    "## 1) Introduction au problème et à sa modélisation\n",
    "\n",
    "### 1.1 Problème de planification de trajectoire (Path Planning)\n",
    "\n",
    "On cherche une trajectoire **sans collision** entre un point de départ **S** et une cible **T**, dans un environnement 2D contenant des obstacles statiques (formes diverses). Le problème est formulé comme une **optimisation sous contraintes** : minimiser une fonction objectif tout en garantissant l’absence de collision. fileciteturn11file16\n",
    "\n",
    "### 1.2 Modélisation du chemin par waypoints dans un repère local\n",
    "\n",
    "L’article propose de représenter un chemin par **D waypoints internes** (sans compter S et T).  \n",
    "Les auteurs fixent les coordonnées **x’** des waypoints en divisant uniformément la distance \\|ST\\| en **D+1 segments** dans un repère local \\(S - X'Y'\\). L’optimisation ne cherche alors que les déviations **y’** sur des droites verticales \\(L_1 \\dots L_D\\). fileciteturn11file8\n",
    "\n",
    "Transformation local → global : on applique une rotation (angle \\(\\theta\\) entre l’axe global et le segment ST) puis une translation par S. fileciteturn11file18\n",
    "\n",
    "**Pourquoi cette modélisation ?**\n",
    "- elle réduit la dimension utile : chaque particule de l’essaim n’encode que les **D valeurs y’** ;\n",
    "- elle garantit que les points progressent dans la direction globale S→T (via x’ uniformes). fileciteturn11file14\n",
    "\n",
    "---\n",
    "\n",
    "## 2) Critères d’évaluation d’une solution\n",
    "\n",
    "Les auteurs combinent trois critères (multi‑objectif) via une somme pondérée (méthode additive). fileciteturn11file16\n",
    "\n",
    "### 2.1 Longueur du chemin \\(L(P)\\)\n",
    "Somme des distances euclidiennes entre points successifs (S, waypoints, T). fileciteturn11file18\n",
    "\n",
    "### 2.2 Risque de collision \\(R(X_{rob}, X_{obs})\\)\n",
    "Risque basé sur un **modèle Gaussien‑like 2D** : le risque est non nul dans une zone d’influence autour des obstacles et nul au‑delà, avec des paramètres de forme (variance/portée) choisis par l’auteur. fileciteturn11file18\n",
    "\n",
    "> Dans une implémentation “preuve de concept”, on peut remplacer ce modèle continu par une version **échantillonnée le long des segments** (détection collision + pénalité de proximité), tout en conservant l’esprit de l’équation (5) (pénaliser la proximité).\n",
    "\n",
    "### 2.3 Douceur \\(S(P)\\) (smoothness)\n",
    "Somme des angles de déflexion (entre trois waypoints consécutifs). Plus le chemin “zigzague”, plus \\(S(P)\\) augmente. fileciteturn11file16\n",
    "\n",
    "### 2.4 Fonction objectif globale\n",
    "\\[\n",
    "J = w_1 L + w_2 R + w_3 S\n",
    "\\]\n",
    "Les poids dépendent du contexte ; dans l’article : **\\(w_1=0.6, w_2=0.3, w_3=0.1\\)**. fileciteturn11file13\n",
    "\n",
    "---\n",
    "\n",
    "## 3) Dataset(s) de référence et métriques\n",
    "\n",
    "### 3.1 Références “datasets” dans l’article\n",
    "\n",
    "1) **Benchmark d’optimisation** : testbed CEC‑2013 (28 fonctions) pour montrer que SLPSO est un bon optimiseur générique. fileciteturn11file11  \n",
    "2) **Environnement simulé** (ROS + Gazebo/Player‑Stage) : workspace **12m × 12m**, obstacles variés, gap minimal ≈ 0.5m. Départ (1,1) → cible (11,11). fileciteturn11file6  \n",
    "3) **Environnement réel** (TurtleBot2) : workspace **12m × 12m**, gap minimal ≈ 0.6m, D=20. fileciteturn11file0  \n",
    "\n",
    "### 3.2 Métriques suivies\n",
    "- \\(L\\) (m), \\(R\\) (degré de risque), \\(S\\) (rad) et coût global \\(J\\). fileciteturn11file2  \n",
    "- **Temps de calcul** / running time. fileciteturn11file2  \n",
    "\n",
    "### 3.3 Paramètres expérimentaux (article)\n",
    "- Population **N=30** (PSO et SLPSO) ; **Itermax = 150** ; fréquence d’update des ratios **Uf = 3** ; \\(\\eta_3=1.496\\). fileciteturn11file5  \n",
    "- D varie de **5 à 30** pour étudier l’impact du nombre de waypoints. fileciteturn11file6  \n",
    "- Critère d’arrêt : Itermax ou amélioration minimale (≈ 1% sur 10 itérations). fileciteturn11file7  \n",
    "\n",
    "---\n",
    "\n",
    "## 4) Résolution du problème : du PSO standard à SLPSO\n",
    "\n",
    "### 4.1 PSO standard (rappel)\n",
    "\n",
    "Chaque particule i possède :\n",
    "- une position \\(X_i\\) (ici : les D valeurs y’),\n",
    "- une vitesse \\(V_i\\),\n",
    "- un **Pbest** (meilleure position personnelle) et un **Gbest** (meilleure globale). fileciteturn11file13  \n",
    "\n",
    "La mise à jour classique combine inertie + apprentissage depuis Pbest et Gbest. fileciteturn11file13\n",
    "\n",
    "### 4.2 SLPSO : idée clé\n",
    "\n",
    "SLPSO emploie **4 opérateurs d’apprentissage** (a,b,c,d) :  \n",
    "- **a (exploitation)** : apprendre depuis Pbest,  \n",
    "- **b (convergence)** : apprendre depuis le meilleur voisin “le plus proche”,  \n",
    "- **c (sortie d’optimum local)** : perturbation,  \n",
    "- **d (exploration)** : apprendre depuis Gbest. fileciteturn11file10  \n",
    "\n",
    "Les probabilités de sélection sont **auto‑adaptées** selon succès + progrès (fenêtre de taille Uf). fileciteturn11file10\n",
    "\n",
    "---\n",
    "\n",
    "## 5) Modélisation du “problem solving” (pseudocode, diagrammes) + complexité\n",
    "\n",
    "### 5.1 Pseudocode (niveau notebook)\n",
    "\n",
    "```text\n",
    "Entrées : environnement, S, T, D, N, Itermax, Uf, paramètres (w1,w2,w3, η3, Vmax, bornes y')\n",
    "\n",
    "1. Construire le repère local S-X'Y' ; fixer x'(d)=|ST|/(D+1)*d\n",
    "2. Initialiser N particules (y' et V), Pbest=position initiale\n",
    "3. Évaluer chaque particule → initialiser Gbest\n",
    "4. Pour k = 1..Itermax :\n",
    "      Pour chaque particule i :\n",
    "          si k mod Uf == 0 : mettre à jour ratios (auto-adaptatif)\n",
    "          choisir un opérateur (a,b,c,d) selon ratios\n",
    "          mettre à jour vitesse/position selon opérateur\n",
    "          gérer violations de bornes (Vmax + réflexion des positions)\n",
    "          évaluer J ; mettre à jour Pbest/Gbest\n",
    "5. Sortie : meilleur chemin = local_to_global(Gbest)\n",
    "```\n",
    "\n",
    "Ce flux correspond à l’Algorithm 1. fileciteturn11file10\n",
    "\n",
    "### 5.2 Complexité\n",
    "- **Temps : O(D·T·N)**. fileciteturn11file10  \n",
    "- **Mémoire : O(N·D)**.\n",
    "\n",
    "---\n",
    "\n",
    "## 6) Narratives et cas d’usage (reproductibles)\n",
    "\n",
    "### 6.1 Cas d’usage minimal (POC)\n",
    "- Workspace 2D, obstacles statiques.\n",
    "- Départ S et cible T.\n",
    "- Paramètres : \\(N=30\\), Itermax=150, D choisi (ex : 5). fileciteturn11file6\n",
    "\n",
    "### 6.2 Reproductibilité (seed)\n",
    "```python\n",
    "import numpy as np, random\n",
    "SEED = 42\n",
    "np.random.seed(SEED)\n",
    "random.seed(SEED)\n",
    "```\n",
    "---\n",
    "\n",
    "## 7) Expériences numériques et tableaux\n",
    "\n",
    "\n",
    "## 8) Analyse : bénéfices, limites, hypothèses de simplification\n",
    "\n",
    "### 8.1 Points forts (article)\n",
    "SLPSO est supérieur à PSO/GA sur le coût global et la vitesse de convergence sur plusieurs D. fileciteturn11file6  \n",
    "\n",
    "### 8.2 Limites + hypothèse de simplification (POC)\n",
    "**Hypothèse de simplification proposée** : *ne traiter qu’un seul cas d’étude stable* (ex. **D=5**) et l’annoncer comme limite.  \n",
    "Justification : lorsque D augmente, la complexité et la difficulté augmentent ; l’article observe que les performances se dégradent au‑delà d’un certain point et que D≈20 est souvent un bon compromis. fileciteturn11file4  \n",
    "\n",
    "Autres limites POC :\n",
    "- risque approché (échantillonnage) ≠ risque exact (Eq.5),\n",
    "- lissage Ferguson spline non implémenté. fileciteturn11file8  \n",
    "\n",
    "### 8.3 Reproductibilité (article)\n",
    "Les paramètres clés sont fournis (N, Uf, η3, poids w1..w3), mais certains détails d’implémentation (collision/risk, discrétisation exacte) restent implicites. fileciteturn11file8  \n",
    "\n",
    "---\n",
    "\n",
    "## 9) Plan de codage suivi (votre architecture)\n",
    "\n",
    "0. Modélisation de l’environnement  \n",
    "1. Modélisation de la trajectoire du robot (`TrajectoireModel`)  \n",
    "2. Évaluation du chemin (fonction de coût) (`EvaluateurChemin`)  \n",
    "3. Implémentation du SLPSO  \n",
    "&nbsp;&nbsp;3.1 `Particle` (création)  \n",
    "&nbsp;&nbsp;3.2 4 stratégies (a,b,c,d)  \n",
    "&nbsp;&nbsp;3.3 auto‑adaptation (ratios, Uf)  \n",
    "&nbsp;&nbsp;3.4 gestion des bornes (Vmax + réflexion) fileciteturn11file10  \n",
    "4. Visualisation (trajectoire + convergence + métriques)\n",
    "\n",
    "---\n",
    "\n",
    "## 10) Références\n",
    "- Li G.S. et al., *Sci China Inf Sci*, 61:052204, 2018. fileciteturn11file2\n",
    "\n",
    "\n",
    "# Rapport — Planification de trajectoire d’un robot mobile par SLPSO (Self‑Adaptive Learning PSO)\n",
    "\n",
    "## 1) Introduction au problème et modélisation\n",
    "\n",
    "### 1.1 Problème de planification de trajectoire (Path Planning)\n",
    "\n",
    "L’article traite du problème de planification de trajectoire pour les robots mobiles\n",
    "Trouver meilleur chemin qu’un robot mobile doit suivre sans collision entre un point de départ S et une cible T dans un environnement 2D contenant des\n",
    "La planification de trajectoire est un problème d’optimisation multi-objectif complexe, car il faut équilibrer plusieurs objectifs à la fois : \n",
    "1.**La longueur du chemin** → le robot doit choisir le chemin le plus court possible.\n",
    "2.**Le risque de collision** → le robot doit éviter de passer trop près des obstacles.\n",
    "3.**La fluidité du mouvement (ou la douceur)** → les virages doivent être lisses pour que le mouvement soit naturel et réalisable dans la pratique\n",
    "\n",
    "### 1.2 Modélisation du chemin par waypoints dans un repère local S–X′Y′\n",
    "\n",
    "L’article propose de représenter un chemin par **D waypoints internes** (sans compter S et T).  \n",
    "Les auteurs fixent les coordonnées **x’** des waypoints en divisant uniformément la distance \\|ST\\| en **D+1 segments** dans un repère local \\(S - X'Y'\\). L’optimisation ne cherche alors que les déviations **y’** sur des droites verticales \\(L_1 \\dots L_D\\). \n",
    "\n",
    "Transformation local → global : on applique une rotation (angle \\(\\theta\\) entre l’axe global et le segment ST) puis une translation par S.\n",
    "\n",
    "## 2) Critères d’évaluation d’une solution\n",
    "\n",
    "Les auteurs combinent trois critères (multi‑objectif) via une somme pondérée (méthode additive). \n",
    "\n",
    "### 2.1 Longueur du chemin \\(L(P)\\)\n",
    "Somme des distances euclidiennes entre points successifs (S, waypoints, T).\n",
    "\n",
    "### 2.2 Risque de collision \\(R(X_{rob}, X_{obs})\\)\n",
    "Risque basé sur un **modèle Gaussien‑like 2D** : le risque est non nul dans une zone d’influence autour des obstacles et nul au‑delà, avec des paramètres de forme (variance/portée) choisis par l’auteur.\n",
    "\n",
    "> Dans une implémentation “preuve de concept”, on peut remplacer ce modèle continu par une version **échantillonnée le long des segments** (détection collision + pénalité de proximité), tout en conservant l’esprit de l’équation (5) (pénaliser la proximité).\n",
    "\n",
    "### 2.3 Douceur \\(S(P)\\) (smoothness)\n",
    "Somme des angles de déflexion (entre trois waypoints consécutifs). Plus le chemin “zigzague”, plus \\(S(P)\\) augmente. \n",
    "\n",
    "### 2.4 Fonction objectif globale\n",
    "\n",
    "La fonction objective globale (J) est une combinaison pondérée de trois critères, formulée comme une minimisation multi-objectif :\n",
    "- **\\(J = w_1 L + w_2 R + w_3 S\\)**\n",
    "- Les poids dépendent du contexte ; dans l’article : **\\(w_1=0.6, w_2=0.3, w_3=0.1\\)**. \n",
    "\n",
    "---\n",
    "\n",
    "## 3) Dataset(s) de référence et métriques\n",
    "\n",
    "### 3.1 Références “datasets” dans l’article\n",
    "\n",
    "1) **Benchmark d’optimisation** : testbed CEC‑2013 (28 fonctions) pour montrer que SLPSO est un bon optimiseur générique. \n",
    "2) **Environnement simulé** (ROS + Gazebo/Player‑Stage) : workspace **12m × 12m**, obstacles variés, gap minimal ≈ 0.5m. Départ (1,1) → cible (11,11). \n",
    "3) **Environnement réel** (TurtleBot2) : workspace **12m × 12m**, gap minimal ≈ 0.6m, D=20.\n",
    "\n",
    "### 3.2 Métriques suivies\n",
    "- J (coût global) \\ (L (longueur) \\ (m (Obstacles ), \\R(collision risk degree), \\ S(smoothness-rad) .\n",
    "- **Temps de calcul** / running time.\n",
    "### 3.3 Paramètres expérimentaux \n",
    "- Population **N=30** (PSO et SLPSO) ; **Itermax = 150** ; fréquence d’update des ratios **Uf = 3** ; \\(\\eta_3=1.496\\). \n",
    "- D varie de **5 à 30** pour étudier l’impact du nombre de waypoints   \n",
    "- Critère d’arrêt : Itermax ou amélioration minimale (≈ 1% sur 10 itérations).\n",
    "- w=0.73  \n",
    "---\n",
    "\n",
    "## 4) Résolution du problème : du PSO standard à SLPSO\n",
    "\n",
    "### 4.1 PSO standard (rappel)\n",
    "\n",
    "Chaque particule i possède :\n",
    "- une position \\(X_i\\) (ici : les D valeurs y’),\n",
    "- une vitesse \\(V_i\\),\n",
    "- un **Pbest** (meilleure position personnelle) et un **Gbest** (meilleure globale). \n",
    "\n",
    "La mise à jour classique combine inertie + apprentissage depuis Pbest et Gbest.\n",
    "\n",
    "### 4.2 SLPSO : idée clé\n",
    "\n",
    "SLPSO emploie **4 opérateurs d’apprentissage** (a,b,c,d) :  \n",
    "- **a (exploitation)** : apprendre depuis Pbest,  \n",
    "- **b (convergence)** : apprendre depuis le meilleur voisin “le plus proche”,  \n",
    "- **c (sortie d’optimum local)** : perturbation,  \n",
    "- **d (exploration)** : apprendre depuis Gbest. \n",
    "Les probabilités de sélection sont **auto‑adaptées** selon succès + progrès (fenêtre de taille Uf).\n",
    "\n",
    "---\n",
    "## 5) Modélisation du “problem solving” (pseudocode, diagrammes) + complexité\n",
    "### 5.1 Pseudocode \n",
    "\n",
    "```text\n",
    "Entrées : environnement, S, T, D, N, Itermax, Uf, paramètres (w1,w2,w3, η3, Vmax, bornes y')\n",
    "\n",
    "1. Construire le repère local S-X'Y' ; fixer x'(d)=|ST|/(D+1)*d\n",
    "2. Initialiser N particules (y' et V), Pbest=position initiale\n",
    "3. Évaluer chaque particule → initialiser Gbest\n",
    "4. Pour k = 1..Itermax :\n",
    "      Pour chaque particule i :\n",
    "          si k mod Uf == 0 : mettre à jour ratios (auto-adaptatif)\n",
    "          choisir un opérateur (a,b,c,d) selon ratios\n",
    "          mettre à jour vitesse/position selon opérateur\n",
    "          gérer violations de bornes (Vmax + réflexion des positions)\n",
    "          évaluer J ; mettre à jour Pbest/Gbest\n",
    "5. Sortie : meilleur chemin = local_to_global(Gbest)\n",
    "```\n",
    "Ce flux correspond à l’Algorithm 1.\n",
    "\n",
    "### classes diagrammes \n",
    "classDiagram\n",
    "  class Environment {\n",
    "    +obstacles\n",
    "    +est_en_collision(point)\n",
    "  }\n",
    "  class TrajectoireModel {\n",
    "    +start\n",
    "    +target\n",
    "    +D\n",
    "    +R\n",
    "    +local_to_global(y_primes)\n",
    "  }\n",
    "  class EvaluateurChemin {\n",
    "    +w1,w2,w3\n",
    "    +calculer_longueur(points)\n",
    "    +calculer_risque(points)\n",
    "    +calculer_douceur(points)\n",
    "    +evaluer(points)\n",
    "  }\n",
    "  class Particle {\n",
    "    +position\n",
    "    +velocity\n",
    "    +pbest_pos\n",
    "    +pbest_cost\n",
    "    +selection_ratios[4]\n",
    "    +success_count[4]\n",
    "    +total_selected[4]\n",
    "    +progress_values[4]\n",
    "    +current_operator\n",
    "  }\n",
    "  class SLPSO {\n",
    "    +swarm\n",
    "    +gbest_pos\n",
    "    +gbest_cost\n",
    "    +history\n",
    "    +optimiser()\n",
    "    +appliquer_strategies()\n",
    "    +mettre_a_jour_ratios()\n",
    "    +gerer_limites()\n",
    "  }\n",
    "\n",
    "  SLPSO --> Particle\n",
    "  SLPSO --> TrajectoireModel\n",
    "  SLPSO --> EvaluateurChemin\n",
    "  EvaluateurChemin --> Environment\n",
    "\n",
    "\n",
    "### 5.2 Complexité\n",
    "- **Temps : O(D·T·N)**.   \n",
    "- **Mémoire : O(N·D)**.\n",
    "\n",
    "### Complexité en temps (Time complexity)\n",
    "\n",
    "**Notations :**\n",
    "- **N** : nombre de particules\n",
    "- **T** : nombre d’itérations (Itermax)\n",
    "- **D** : nombre de waypoints internes (dimension de la particule)\n",
    "- **M** : nombre d’obstacles (ici **M = 10**)\n",
    "- **n_samples** : nombre de points d’échantillonnage par segment (pour le risque)\n",
    "\n",
    "#### a) Coût “de base” de SLPSO\n",
    "À chaque itération (**T**), l’algorithme met à jour **N** particules.  \n",
    "Chaque mise à jour manipule des vecteurs de taille **D** (position/vitesse, calculs sur les waypoints).  \n",
    "Donc le coût de base est :\n",
    "\\[\n",
    "  O(T \\cdot N \\cdot D)\n",
    "\\]\n",
    "#### b) Surcoût dû au calcul du risque (dominant dans le PoC)\n",
    "Dans notre PoC, le risque n’est pas évalué seulement sur les waypoints, mais **sur les segments** du chemin :\n",
    "\n",
    "- Un chemin contient environ **D+1 segments** (S→P1, ..., PD→T).\n",
    "- Chaque segment est discrétisé en **n_samples** points.\n",
    "- Chaque point est comparé à **M = 10 obstacles**.\n",
    "\n",
    "Le coût du risque pour une trajectoire est donc :\n",
    "\\[\n",
    "O((D+1) \\cdot n\\_{samples} \\cdot M) \\approx O(D \\cdot n\\_{samples} \\cdot 10)\n",
    "\\]\n",
    "\n",
    "Comme ce calcul est fait pour chaque particule et chaque itération, le coût total “pratique” devient :\n",
    "\\[\n",
    "O(T \\cdot N \\cdot D \\cdot n\\_{samples} \\cdot 10)\n",
    "\\]\n",
    "\n",
    "**Interprétation :**\n",
    "- augmenter **D** augmente le nombre de segments à tester → le calcul devient plus coûteux ;\n",
    "- plus il y a d’échantillons (**n_samples**) et d’obstacles (**M**), plus l’évaluation ralentit.\n",
    "\n",
    "---\n",
    "\n",
    " ### Complexité en mémoire (Space complexity)\n",
    "\n",
    "Pour chaque particule (au nombre de **N**), on stocke principalement des vecteurs de taille **D** :\n",
    "- `position` (D)\n",
    "- `velocity` (D)\n",
    "- `pbest_pos` (D)\n",
    "\n",
    "Donc la mémoire principale est de l’ordre :\n",
    "\\[\n",
    "O(N \\cdot D)\n",
    "\\]\n",
    "\n",
    "On ajoute :\n",
    "- `gbest_pos` : \\(O(D)\\)\n",
    "- l’historique de convergence `history` : \\(O(T)\\)\n",
    "\n",
    "Au total :\n",
    "\\[\n",
    "O(ND + T) \\approx O(ND)\n",
    "\\]\n",
    "(car en général \\(ND\\) domine \\(T\\)).\n",
    "\n",
    "---\n",
    "\n",
    "## 6) Narratives et cas d’usage (reproductibles)\n",
    "\n",
    "### 6.1 Cas d’usage minimal (POC)\n",
    "- Workspace 2D, obstacles statiques.\n",
    "- Départ S et cible T.\n",
    "- Paramètres : \\(N=30\\), Itermax=150, D choisi (ex : 5).\n",
    "\n",
    "### 6.2 Reproductibilité (seed)\n",
    "```python\n",
    "import numpy as np, random\n",
    "SEED = 42\n",
    "np.random.seed(SEED)\n",
    "random.seed(SEED)\n",
    "```\n",
    "---\n",
    "\n",
    "## 7) Expériences numériques\n",
    "\n",
    "\n",
    "## 8) Analyse : bénéfices, limites, hypothèses de simplification\n",
    "\n",
    "### 8.1 Points forts (article)\n",
    "SLPSO est supérieur à PSO/GA sur le coût global et la vitesse de convergence sur plusieurs D.  \n",
    "\n",
    "### 8.2 Limites + hypothèse de simplification (POC)\n",
    "**Hypothèse de simplification proposée** : *ne traiter qu’un seul cas d’étude stable* (ex. **D=5**) et l’annoncer comme limite.  \n",
    "Justification : lorsque D augmente, la complexité et la difficulté augmentent ; l’article observe que les performances se dégradent au‑delà d’un certain point et que D≈20 est souvent un bon compromis. \n",
    "\n",
    "Autres limites POC :\n",
    "- risque approché (échantillonnage) ≠ risque exact (Eq.5),\n",
    "- lissage Ferguson spline non implémenté.   \n",
    "\n",
    "### 8.3 Reproductibilité (article)\n",
    "Les paramètres clés sont fournis (N, Uf, η3, poids w1..w3), mais certains détails d’implémentation (collision/risk, discrétisation exacte) restent implicites. \n",
    "\n",
    "---\n",
    "\n",
    "## 9) Plan de codage suivi (votre architecture)\n",
    "\n",
    "0. Modélisation de l’environnement  \n",
    "1. Modélisation de la trajectoire du robot (`TrajectoireModel`)  \n",
    "2. Évaluation du chemin (fonction de coût) (`EvaluateurChemin`)  \n",
    "3. Implémentation du SLPSO  \n",
    "&nbsp;&nbsp;3.1 `Particle` (création)  \n",
    "&nbsp;&nbsp;3.2 4 stratégies (a,b,c,d)  \n",
    "&nbsp;&nbsp;3.3 auto‑adaptation (ratios, Uf)  \n",
    "&nbsp;&nbsp;3.4 gestion des bornes (Vmax + réflexion) \n",
    "4. Visualisation (trajectoire + convergence + métriques)\n",
    "5. 4. Implémentation du pso\n",
    "5. Implémentation du GA\n",
    "6. Affichages des résultats globaux \n",
    "---\n",
    "\n",
    "## 10) Références\n",
    "- Li G S, Chou W S. Path planning for mobile robot using self-adaptive learning particle swarm opti\u0002mization. Sci China Inf Sci, 2018, 61(5): 052204, doi: 10.1007/s11432-016-9115- "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0749bfa2-b27c-437f-8c43-48c8aec5c700",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
